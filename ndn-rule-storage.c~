
#include "ndn-rule-storage.h"

static ndn_rule_storage_t ndn_rule_storage;

// returns 0 if buffer contained only zeros
int _check_buffer_all_zeros(const char *buf, int buf_size) {
  int sum = 0;
  for (int i = 0; i < buf_size; i++) {
    sum |= buf[i];
  }
  return sum;
}

ndn_rule_storage_t*
get_ndn_rule_storage_instance() {
  return &ndn_rule_storage;
}

void
ndn_rule_storage_init() {
  for (int i = 0; i < NDN_TRUST_SCHEMA_MAX_SUBPATTERN_MATCHES; i++) {
    memset(&ndn_rule_storage.rule_objects[i], 0, sizeof(ndn_trust_schema_rule_t));
    ndn_rule_storage.rule_names[i].name[NDN_TRUST_SCHEMA_PATTERN_COMPONENT_BUFFER_SIZE-1] = '\0';
  }
}

int
ndn_rule_storage_get_rule(const char *rule_name, ndn_trust_schema_rule_t *rule) {
  int ret_val = -1;
  for (int i = 0; i < NDN_TRUST_SCHEMA_MAX_SUBPATTERN_MATCHES; i++) {
    if (strcmp((const char *)&ndn_rule_storage.rule_names[i].name, rule_name) == 0 &&
	strlen((const char *)&ndn_rule_storage.rule_names[i].name) == strlen(rule_name)) {
      printf("index of found rule: %d\n", i);
      printf("Num subpattern captures in found rule: %d\n", ndn_rule_storage.rule_objects[i].data_pattern.num_subpattern_captures);
      rule = &ndn_rule_storage.rule_objects[i];
      return NDN_SUCCESS;
    }
  }
  rule = NULL;
  return NDN_TRUST_SCHEMA_RULE_NOT_FOUND;  
}

int
ndn_rule_storage_add_rule(const char* rule_name, const ndn_trust_schema_rule_t *rule) {
  int ret_val = -1;
  int empty_index = -1;

  for (int i = 0; i < NDN_TRUST_SCHEMA_MAX_SUBPATTERN_MATCHES; i++) {
    if (strcmp((const char *)&ndn_rule_storage.rule_names[i].name, rule_name) == 0 &&
	strlen((const char *)&ndn_rule_storage.rule_names[i].name) == strlen(rule_name)) {
      return NDN_TRUST_SCHEMA_DUPLICATE_RULE_NAME;
    }
    if (_check_buffer_all_zeros((uint8_t *) &ndn_rule_storage.rule_objects[i], sizeof(ndn_trust_schema_rule_t)) == 0) {
      printf("Adding rule %s to index %d\n", rule_name, i);
      empty_index = i;
    }
  }

  if (empty_index == -1)
    return NDN_TRUST_SCHEMA_RULE_STORAGE_FULL;
  
  ret_val = ndn_trust_schema_rule_copy(rule, &ndn_rule_storage.rule_objects[empty_index]);
  printf("Num subpattern captures in copied rule (index %d): %d\n", empty_index,
	 ndn_rule_storage.rule_objects[empty_index].data_pattern.num_subpattern_captures);
  if (ret_val != 0) return ret_val;
  if (strlen(rule_name) > NDN_TRUST_SCHEMA_RULE_NAME_MAX_LENGTH)
    return NDN_TRUST_SCHEMA_RULE_NAME_TOO_LONG;
  memcpy(&ndn_rule_storage.rule_names[empty_index].name, rule_name, strlen(rule_name));
  ndn_rule_storage.rule_names[empty_index].name[strlen(rule_name)] = '\0';
  return NDN_SUCCESS;
}

int
ndn_rule_storage_remove_rule(const char* rule_name) {
  int ret_val = -1;
  for (int i = 0; i < NDN_TRUST_SCHEMA_MAX_SUBPATTERN_MATCHES; i++) {
    if (strcmp((const char *)&ndn_rule_storage.rule_names[i].name, rule_name) == 0 &&
	strlen((const char *)&ndn_rule_storage.rule_names[i].name) == strlen(rule_name)) {
      memset(&ndn_rule_storage.rule_objects[i], 0, sizeof(ndn_trust_schema_rule_t));
      ndn_rule_storage.rule_names[i].name[0] = '\0';
      return NDN_SUCCESS;
    }
  }
  return NDN_TRUST_SCHEMA_RULE_NOT_FOUND;    
}
